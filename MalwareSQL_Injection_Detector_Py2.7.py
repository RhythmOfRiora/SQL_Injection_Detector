# -*- coding: cp1252 -*-
import sys
import os
import re
import codecs
import argparse
from argparse import ArgumentParser

# Dictionary to hold the results.
results = {"TP": 0, "TN": 0, "FP":0, "FN":0}

# The white list of regular expressions.
white_list = ["SELECT\s((\*)|(DISTINCT\s[a-zA-Z,]+)|([\sa-zA-Z,()]+))\sFROM\s([A-Z][a-z]+|[a-z]+)((\sORDER\sBY\s([A-Z][a-z]+|[a-z]+)))?\;$",
"SELECT\s((\*)|(DISTINCT\s[a-zA-Z,]+)|([\sa-zA-Z,]+))\sFROM\s([A-Z][a-z]+|[a-z]+)((\sORDER\sBY\s([A-Z][a-z]+|[a-z]+)))?\;$",
"SELECT\s((\*)|(DISTINCT\s[a-zA-Z,]+)|([\sa-zA-Z,]+))\sFROM\s([A-Z][a-z]+|[a-z]+)((\sORDER\sBY\s([A-Z][a-z]+|[a-z]+)))?((\sWHERE\s[\sa-zA-Z,\*\'\=]+))?((\;))?$",
"SELECT\sCOUNT\s\*\sFROM\s([A-Z][a-z]+|[a-z]+)\;$",
"SELECT\s((\*)|([\sa-zA-Z,]+))\sFROM\s([A-Z][a-z]+|[a-z]+)((\sWHERE\s[\sa-zA-Z,\*\'\=]+))((\;))?$",
"SELECT\s([a-zA-Z]+)\(([a-zA-Z]+)\)\sFROM\s([A-Z][a-z]+|[a-z]+)\;$",
"SELECT\s((\*)|([\sa-zA-Z,()]+))\sFROM\s([A-Z][a-z]+|[a-z]+)\sWHERE\s.+?\;$",
"UPDATE.+?SET\s[a-z]+\s?\=[a-z'\s]+((\;$)|(\sWHERE\s.+?\;$))",
"INSERT INTO\s([a-zA-Z\(\)\,\s]+)\sVALUES([a-zA-Z\(\)\,\s\'\d]+)\;$",
"DELETE((\s)|(\s[a-zA-Z]+\s))FROM\s([A-Z][a-z]+|[a-z]+)\sWHERE\s.+?\;$"]

# The black list of regular expressions. This includes attempts at obfuscation such as HTML character codes.
black_list = ["[\x22\x27]\s*OR\s*\d+\x3d\d+", "(OR|AND)(\s+?).+?=[\x22\x27](\s+?)[\x22\x27]$",
      "(OR|AND)(\s+?).+?=(\s+?)[\x22\x27]$", "([\x22\x27])?(\s+?)--(\s+?)([\x22\x27])?",
      ".+?=[\x22\x27]\*[\x22\x27]\s(AND|OR)\s.+?=[\x22\x27][\x22\x27]", "\x3bDROP",
      "((\x27)|(\x22))\*((\x27)|(\x22))",
      "#.+?WHERE.+?SELECT", "--.+?[\x22\x27]","%27%20","\/\*|\*\/",";.+?$",
      "\w*((\%27)|(\'))(\s?)((\%6F)|(\%4F))((\%72)|(\%52))",
      "\w*((\%27)|(\'))(\s?)((\%6F)|o|(\%4F))((\%72)|r|(\%52))",
      "\w*((\%6F)|(\%4F))((\%72)|(\%52))(\s?)((\%27)|(\'))",".+?(\%2A).+?$",
      ".+?(0x3(a|A)).+?$", ".+?information_schema.+?$"]

# The white list, for when no files are passed in as arguments on the command line.
benign_queries = ["SELECT CustomerName,City FROM Customers;",
"SELECT * FROM student ORDER BY age;",
"SELECT * FROM student;",
"INSERT INTO student (id, name, age) VALUES ('4', 'chris', '28');",
"SELECT COUNT * FROM student;",
"SELECT id , name , MAX(age) FROM student;",
"SELECT sum(age) FROM student;",
"SELECT * FROM student WHERE name = ‘dan’ AND age = 24;",
"SELECT * FROM student WHERE name = ‘dan’ OR age > 25;",
"SELECT name FROM student WHERE age > 25;",
"INSERT INTO Customers (CustomerName, City, Country) VALUES ('Cardinal', 'Stavanger', 'Norway');",
"UPDATE Customers SET ContactName='Alfred Schmidt', City='Hamburg';",
"SELECT * FROM Customers WHERE City IN ('Paris','London');",
"SELECT * FROM Customers WHERE CustomerID=1;",
"SELECT * FROM Customers WHERE Country='Germany' AND City='Berlin';",
"SELECT * FROM Customers WHERE Country LIKE '%land%';",
"UPDATE Customers SET ContactName='Alfred Schmidt', City='Hamburg' WHERE CustomerName='Alfreds Futterkiste';",
"DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste';",
"SELECT DISTINCT City FROM Customers;",
"SELECT * FROM Persons WHERE ROWNUM <=5;",
"SELECT * FROM Customers WHERE Country='Germany' AND (City='Berlin' OR City='München');",
"SELECT * FROM Customers WHERE City LIKE '[bsp]%';",
"SELECT * FROM Products WHERE ProductName BETWEEN 'C' AND 'M';",
"SELECT City FROM Customers UNION SELECT City FROM Suppliers ORDER BY City;",
"SELECT * FROM Customers WHERE City='Berlin' OR City='München';" ]

# The white list, for when no files are passed in as arguments on the command line.
malicious_queries = ["SELECT * FROM users WHERE username='*' AND password=''",
"SELECT * FROM users WHERE username='admin'--' AND password=''",
"SELECT * FROM users WHERE username='admin' AND password='' OR 1=1--'",
"SELECT * FROM users WHERE username='';SHUTDOWN --' AND password=''",
"SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'",
"SELECT * FROM users WHERE username='SELECT Username FROM Users WHERE ID=1' AND password='SELECT MD5(Password) FROM Users WHERE ID=1'",
"SELECT * FROM users WHERE username='*' AND password=''",
"SELECT * FROM users WHERE username='admin'#' AND password=''",
"SELECT * FROM users WHERE username='';DROP tempTable;' AND password=''",
"SELECT * FROM users WHERE username='admin' AND password='' OR 1=1 --IamJOE'",
"SELECT * FROM users WHERE username='admin' AND password=' ' OR ''=''",
"SELECT * FROM users WHERE username='admin' AND password=%27%20or%20%27%27%3D%27",
"SELECT * FROM users WHERE username='' AND password='' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1-- '",
"SELECT * FROM users WHERE username='' AND users NOT IN ('First User', 'Second User');--' AND password=''",
"SELECT * FROM users WHERE username='admin';DROP myTable--' AND password=''",
"SELECT * FROM users WHERE username='/*!32302 1/0, */' AND password='' ",
"SELECT * FROM users WHERE username='' AND password='';IF((SELECT user) = 'sa' OR (SELECT user) = 'dbo') SELECT 1 ELSE SELECT 1/0;--'",
"SELECT * FROM users WHERE username='';waitfor delay '0:0:10'--' AND password=''",
"SELECT * FROM users WHERE username='CAST('username' AS SIGNED INTEGER)' AND password=''",
"SELECT * FROM users WHERE username='' UNION SELECT SUM(columntofind) FROM users--' AND password=''",
"SELECT * FROM users WHERE username='' AND password='' ORDER BY 1;--'",
"SELECT * FROM users WHERE username='' + (SELECT TOP 1 username FROM users ) + '' AND password='' + (SELECT TOP 1 password FROM users ) + ''",
"SELECT * FROM users WHERE username='';SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'known_table_name');--' AND password=''",
"SELECT table_name FROM information_schema.columns WHERE column_name = 'username';",
"SELECT table_name FROM information_schema.columns WHERE column_name LIKE '%user%';",
"SELECT column_name FROM information_schema.columns WHERE table_name = 'Users';",
"SELECT column_name FROM information_schema.columns WHERE table_name LIKE '%user%';?"]


# This function performs the bulk of the work. 
def get_Input(malicious_queries=malicious_queries, benign_queries=benign_queries):
    correctly_classified = {}
    incorrectly_classified = {}
    
    # For each query, analyse.
    for q in malicious_queries:
        isMalicious = True
        isDetectedAsMalicious = analyse(q)
        classify(isDetectedAsMalicious,q, isMalicious, correctly_classified, incorrectly_classified)
       
    for q in benign_queries:
        isMalicious = False
        q.strip()
        isDetectedAsMalicious = analyse(q)
        classify(isDetectedAsMalicious,q, isMalicious, correctly_classified, incorrectly_classified)

    return correctly_classified, incorrectly_classified

# This function classifies the returned result and determines if classification is correct.
def classify(isDetectedAsMalicious,q, isMalicious, correctly_classified, incorrectly_classified):
    classification = testifcorrect(isDetectedAsMalicious,q, isMalicious)
    if classification:
        correctly_classified[q] = classification
    else:
        incorrectly_classified[q] = classification
    
# This function prepares the output file.
def prepare_Output():
    outfile = open("Detection_Results.txt", 'w+')
    outfile.write("RESULTS OF DETECTION: \n\n")
    # Ensure that the count in the results is an integer count.
    for key in results:
        results[key] = int(results[key])
    return outfile

# This function writes to the output file.
def output_results(outfile, corr, incorr):
    outfile.write("True Positives: %r\n" % results['TP'])
    outfile.write("True Negatives: %r\n" % results['TN'])
    outfile.write("False Positives: %r\n" % results['FP'])
    outfile.write("False Negatives: %r\n\n" % results['FN'])
    outfile.write("\nCorrectly Classified: %r\n\n" % len(corr))
    for x in corr: outfile.write(x + "\n")
    outfile.write("\nIncorrectly Classified: %r\n\n" % len(incorr))
    for x in incorr: outfile.write(x + "\n")
    
# This function determines whether files passed in via command line are valid files.
def is_valid_file(parser, arg):
    if not os.path.exists(arg):
        parser.error("The file %s does not exist. Try again with a valid file path." % arg)
        sys.exit()
    else:
        return open(arg, 'r')
    
# This will determine if the result is a TP, FP, TN or FN.
def testifcorrect(isDetectedAsMalicious, query, isMalicious):
    if isMalicious == True and isDetectedAsMalicious == True:
        results["TP"]+=1
        return True
    elif isMalicious == True and isDetectedAsMalicious == False:
        results["FN"]+=1
        return False
    elif isMalicious == False and isDetectedAsMalicious == True:
        results["FP"]+=1
        return False
    else:
        results["TN"]+=1
        return True
                 
# This will analyse the lines in the file.
def analyse(query):
    passedGrammarCheck = isGrammarCorrect(query)
    passedWhitelist = testAgainstWhitelist(query)
    
    if passedGrammarCheck == False:
        return True
    elif passedWhitelist == False:
        return True
    return testAgainstBlacklist(query)

# This tests a query against the white list regex.
def testAgainstWhitelist(q):
    matchobject = None
    for line in white_list:
            reg = re.compile(line)
            matchobject = reg.search(q)
            if matchobject is not None:
                return True

    if matchobject == None:
        return False

# This tests a query against the black list regex.
def testAgainstBlacklist(q):
    matchobject = None
    for line in black_list:
            reg = re.compile(line)
            matchobject = reg.search(q)
            if matchobject is not None:
                return True

    if matchobject == None:
        return False

# This tests if all quotation marks are closed.
def isGrammarCorrect(line):
    if line.count("\'") % 2 != 0 or line.count('\"') % 2 != 0:
        #print "Grammar not correct in %s." % line
        return False
    if line.count("(") != line.count(")"):
        #print "Grammar not correct in %s." % line
        return False
    else:
        return True

# This analyses an unseen query.
def analyseNew(query):
    if isGrammarCorrect(query) == False:
        return True, 0
    if testAgainstWhitelist(query) == False:
        return True, 1
    if testAgainstBlacklist(query) == True:
        return True, 2
    else:
        return False, 3

# This function gives results of testing an unseen query.
def testQuery(query):
    isDetectedAsMalicious, fail_list = analyseNew(query)
    if fail_list == 0:
        print "\n This query failed at the grammar analysis stage. Please ensure that all brackets and quotation marks are closed."
    elif fail_list == 1:
        print"\nThis query failed at the whitelist stage. This would suggest that it is either incorrect syntactically, or is too complex for this detector, at present."
    elif fail_list == 2:
        print"\nThis query failed at the black list stage: it contains some code that could be considered malicious."
    else:
        print" \nThis code passed all filters and can be considered safe, however further measures must be taken to ensure that injection has not occurred."

# This function prints the queries that are run through the detector by default.
def printQueries():
    print"Queries that the Detector will be run on: \n"
    print"\n".join(benign_queries)
    print"\n".join(malicious_queries)
    print"\n\n\n"

# This is the main function where command line args are parsed, etc.        
def main():
    try:
        parser = argparse.ArgumentParser(description='A SQL Injection Detector. The arguments are files; a test file, a white list and a black list.')
        parser.add_argument("--query", dest="query", required=False,
                    help="A query to be tested on the fly.")
        parser.add_argument("--printQueries", dest = "printQueries", required=False, action='store_true',
                    help="Print the default queries that will be run through the detector.")
        parser.add_argument("--benign", dest = "benign_list", required=False,
                    help="The benign SQL files to be tested against", metavar="FILE",
                    type=lambda x: is_valid_file(parser, x))
        parser.add_argument('--malicious', dest = "mal_list", required=False,
                    help="The malicious SQL files to be tested against", metavar="FILE",
                    type=lambda x: is_valid_file(parser, x))
        args = parser.parse_args()

        # If no arguments have been passed in...
        #if args == None:
          #  parser.print_help()
           # sys.exit()
        #else:
            # Load data.
        if args.query is not None:
            query = args.query
            testQuery(query)
        if args.printQueries:
            printQueries()
                
        if args.query is None:
            outfile = prepare_Output()
            if args.benign_list is not None and args.mal_list is not None:
                mal_list = args.mal_list
                benign_list = args.benign_list
                c, inc = get_Input(mal_list, benign_list)
            else:
                c, inc = get_Input()
            output_results(outfile, c, inc)
            print"\nANALYSIS COMPLETE!\n"
            print"""\nPlease see the output file 'Detection_Results.txt' for details of false positives, false negatives, true positives and true negatives, along with the queries that were correctly and incorrectly classified."""
            outfile.close()
    except:
        print("Unexpected error:"), sys.exc_info()[0]
        raise

if __name__ == "__main__":
    main()

    
    
